#!/usr/bin/env python

import sys
import re
import argparse
from argparse import RawTextHelpFormatter
from gccwarnings import VERSION
from gccwarnings.utils import FirstLineMatcher, AnyLineMatcher, parse_warnings, filter_warnings, fuzzy_find


def first_line_matcher(string):
    try:
        return FirstLineMatcher(string)
    except re.error:
        msg = "%s is not valid pattern" % string
        raise argparse.ArgumentTypeError(msg)


def any_line_matcher(string):
    try:
        return AnyLineMatcher(string)
    except re.error:
        msg = "%s is not valid pattern" % string
        raise argparse.ArgumentTypeError(msg)


def positive_int(string):
    i = int(string)
    if i < 0:
        raise argparse.ArgumentTypeError("%s is a negative value" % string)
    return i


def main():
    parser = argparse.ArgumentParser(description='Utility to process warnings produced by GCC (and other tools producing GCC-like output).',
                                     formatter_class=RawTextHelpFormatter)
    parser.add_argument('input', metavar='FILE', nargs='?', type=argparse.FileType('r'), default=sys.stdin,
                        help='Input warnings (defaults to stdin).')
    parser.add_argument('--diff', dest='diff', metavar='FILE', type=argparse.FileType('r'),
                        help='Previous set of warnings to diff from.')
    parser.add_argument('--dst', dest='dst', metavar='N', type=positive_int, default=8,
                        help='To use with --diff to specify the edition distance threshold.\n'
                             'Warnings with an edition distance < to this value will be considered as already known and will be dropped.')
    parser.add_argument('--include', metavar='PATTERN', nargs='+', type=any_line_matcher, default=list(),
                        help='Will only keep warnings matching one of the patterns.')
    parser.add_argument('--include1', metavar='PATTERN', nargs='+', type=first_line_matcher, default=list(),
                        help='Will only keep warnings whose first line is matching  one of the patterns.')
    parser.add_argument('--exclude', metavar='PATTERN', nargs='+', type=any_line_matcher, default=list(),
                        help='Will discard warnings matching any of the patterns.')
    parser.add_argument('--exclude1', metavar='PATTERN', nargs='+', type=first_line_matcher, default=list(),
                        help='Will discard warnings whose first line is matching any of the patterns.')
    parser.add_argument('--sep', dest='sep', metavar='STRING',
                        help='Optional separator to print between entries.')

    parser.add_argument('--version', '-v', action='version', version='.'.join(str(v) for v in VERSION))

    args = parser.parse_args()

    include_patterns = args.include1 + args.include
    exclude_patterns = args.exclude1 + args.exclude

    warnings = [warning for warning in parse_warnings(args.input.readlines())]
    warnings = filter_warnings(warnings, include=include_patterns, exclude=exclude_patterns)
    warnings = list(["\n".join(lines) for lines in warnings])

    if args.diff is not None:
        prev = [warning for warning in parse_warnings(args.diff.readlines())]
        prev = filter_warnings(prev, include=include_patterns, exclude=exclude_patterns)
        prev = list(["\n".join(lines) for lines in prev])

        warnings = [warning for warning in warnings if not fuzzy_find(warning, prev, args.dst)]

    for i, warning in enumerate(warnings):
        if i > 0 and args.sep is not None:
            print(args.sep)

        print(warning)


if __name__ == '__main__':
    main()
